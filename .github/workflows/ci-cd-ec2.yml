name: CI/CD - CarStoreBack (Tests + SonarCloud + Deploy EC2)

on:
  push:
    branches: ["main"]
  pull_request:

concurrency:
  group: deploy-main
  cancel-in-progress: true

jobs:
  test_and_sonar:
    name: Build and analyze
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: temurin
          cache: maven

      # Se você estiver usando mvnw, pode trocar por ./mvnw -B verify ...
      - name: Build + Sonar (Maven)
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: mvn -B verify org.sonarsource.scanner.maven:sonar-maven-plugin:sonar -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }}

  build_and_push:
    name: Build & Push Docker (ECR)
    runs-on: ubuntu-latest
    needs: [test_and_sonar]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    outputs:
      image_uri: ${{ steps.build.outputs.image_uri }}

    steps:
      - uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then echo "Missing secret: AWS_ACCESS_KEY_ID"; exit 1; fi
          if [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then echo "Missing secret: AWS_SECRET_ACCESS_KEY"; exit 1; fi
          if [ -z "${{ secrets.ECR_REPOSITORY }}" ]; then echo "Missing secret: ECR_REPOSITORY (ex: car-back)"; exit 1; fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            us-east-2

      - name: Login to Amazon ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & push image
        id: build
        env:
          REGISTRY: ${{ steps.ecr.outputs.registry }}
          REPO: ${{ secrets.ECR_REPOSITORY }}
          TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          echo "DEBUG REGISTRY=$REGISTRY"
          echo "DEBUG REPO=$REPO"
          echo "DEBUG TAG=$TAG"

          if [ -z "$REGISTRY" ] || [ -z "$REPO" ] || [ -z "$TAG" ]; then
            echo "ERRO: REGISTRY/REPO/TAG vazio. Verifique login no ECR e secret ECR_REPOSITORY."
            exit 1
          fi

          IMAGE_URI="${REGISTRY}/${REPO}:${TAG}"
          echo "DEBUG IMAGE_URI=$IMAGE_URI"

          echo "image_uri=${IMAGE_URI}" >> "$GITHUB_OUTPUT"

          docker build -t "$IMAGE_URI" .
          docker push "$IMAGE_URI"

  deploy:
    name: Deploy EC2
    runs-on: ubuntu-latest
    needs: [build_and_push]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v4

      - name: Debug image uri from needs
        run: |
          echo "image_uri='${{ needs.build_and_push.outputs.image_uri }}'"

      - name: Upload docker-compose.yml to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          source: "docker-compose.yml"
          target: ${{ secrets.EC2_APP_DIR }}

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          script_stop: true
          script: |
            set -euo pipefail

            APP_DIR="${{ secrets.EC2_APP_DIR }}"
            mkdir -p "$APP_DIR"
            cd "$APP_DIR"

            APP_IMAGE="${{ needs.build_and_push.outputs.image_uri }}"
            if [ -z "$APP_IMAGE" ]; then
              echo "ERRO: APP_IMAGE veio vazio (needs.build_and_push.outputs.image_uri)."
              echo "Causas comuns: build_and_push não rodou (PR) ou ECR_REPOSITORY/secrets faltando."
              exit 1
            fi

            cat > .env <<EOF
            APP_IMAGE=${APP_IMAGE}
            DB_HOST=${{ secrets.DB_HOST }}
            DB_PORT=${{ secrets.DB_PORT }}
            DB_NAME=${{ secrets.DB_NAME }}
            DB_USER=${{ secrets.DB_USER }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            ADMIN_EMAIL=${{ secrets.ADMIN_EMAIL }}
            ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
            CARSTORE_VIEW_BASE_URL=${{ secrets.CARSTORE_VIEW_BASE_URL }}
            SPRING_PROFILES_ACTIVE=${{ secrets.SPRING_PROFILES_ACTIVE }}
            KEYS_DIR=${{ secrets.KEYS_DIR }}
            EOF

            # rede externa do compose
            docker network inspect carstore_net >/dev/null 2>&1 || docker network create carstore_net

            # login no ECR usando o registry derivado da imagem
            ECR_REGISTRY="$(echo "$APP_IMAGE" | cut -d/ -f1)"
            if [ -z "$ECR_REGISTRY" ]; then
              echo "ERRO: ECR_REGISTRY vazio (APP_IMAGE inválida: $APP_IMAGE)"
              exit 1
            fi

            aws ecr get-login-password --region "us-east-2" \
              | docker login --username AWS --password-stdin "$ECR_REGISTRY"

            # evita puxar postgres do Docker Hub -> puxa só seu serviço
            docker compose --env-file .env pull car-backend
            docker compose --env-file .env up -d --no-build

            docker image prune -f